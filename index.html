<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Croc Knives - Swamp Challenge!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
    <style>
        /* Basic styling for the page */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh; /* Use min-height */
            /* REMOVED: height: 100vh; */
            margin: 0;
            padding: 10px;
            background: linear-gradient(180deg, #87CEEB 0%, #a0d8ef 50%, #64c2f4 100%);
            font-family: 'Luckiest Guy', cursive;
            overflow: hidden;
            color: #333;
            box-sizing: border-box;
        }

        /* Style for the game canvas */
        canvas {
            display: block;
            border: 4px solid #5c3d21;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0,0,0,0.1);
            touch-action: none;
            background: #a0d8ef;
            max-width: 100%;
            /* REMOVED: flex-shrink: 0; */
            /* Ensure it doesn't exceed viewport height if aspect ratio makes it too tall */
            max-height: calc(100vh - 100px); /* Example: leave ~100px for UI/padding */
        }

        /* Style for the UI container */
        #ui-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 10px;
            margin-bottom: 10px;
            background: linear-gradient(180deg, #66bb6a 0%, #4caf50 50%, #388e3c 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 2px solid #2e7d32;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            /* REMOVED: flex-shrink: 0; */
        }

        /* UI text element style - unchanged */
        .ui-element { font-size: clamp(1.1em, 3vw, 1.6em); font-weight: normal; letter-spacing: 1px; margin: 5px 10px; }

        /* Reset Button style - unchanged */
        #reset-button { padding: 8px 15px; font-size: clamp(0.9em, 2.5vw, 1.1em); font-family: 'Luckiest Guy', cursive; font-weight: normal; color: white; background: linear-gradient(180deg, #ef5350 0%, #f44336 50%, #e53935 100%); border: 2px solid #c62828; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2); text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); margin: 5px; }
        #reset-button:hover { background: linear-gradient(180deg, #e53935 0%, #d32f2f 50%, #c62828 100%); box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3); transform: translateY(-1px); }
        #reset-button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }

        /* Message box style - unchanged */
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(40, 40, 40, 0.9); color: #fff; width: 85%; max-width: 500px; padding: 25px; border-radius: 15px; font-size: clamp(1.1em, 3.5vw, 1.6em); text-align: center; display: none; z-index: 10; border: 3px solid #fdd835; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4); text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); box-sizing: border-box; line-height: 1.5; white-space: pre-wrap; }
        #message-box h2 { font-size: 1.5em; color: #fdd835; margin-top: 0; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px; }
        #message-box p { margin: 10px 0; }
        #message-box strong { color: #fdd835; }
        #message-box .prize-code { display: inline-block; background-color: rgba(0, 0, 0, 0.3); padding: 5px 10px; border-radius: 5px; font-size: 1.1em; color: #fff; margin-top: 5px; word-break: break-all; }
        #message-box .instructions { font-size: 0.9em; opacity: 0.9; margin-top: 20px; }
        #message-box button { display: inline-block; padding: 12px 24px; font-size: 1em; font-family: 'Luckiest Guy', cursive; font-weight: normal; color: white; background: #1DA1F2; border: 2px solid #0c85d0; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2); text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4); margin-top: 20px; text-decoration: none; }
        #message-box button:hover { background: #0c85d0; box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3); transform: translateY(-1px); }
        #message-box button:active { transform: translateY(1px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }

        /* Loading Indicator Style - unchanged */
        #loading-indicator { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); color: white; display: flex; justify-content: center; align-items: center; font-size: 1.5em; z-index: 100; font-family: 'Luckiest Guy', cursive; }

    </style>
</head>
<body>
    <div id="loading-indicator">Loading Game Assets...</div>

    <div id="ui-container" style="display: none;"> <div id="score" class="ui-element">Score: 0</div>
        <div id="knives-left" class="ui-element">Knives: 4</div>
        <button id="reset-button">Reset Level</button>
    </div>

    <canvas id="game-canvas" style="display: none;"></canvas> <div id="message-box"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        function setupGame() {
            // --- Matter.js Module Aliases ---
            const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner, World = Matter.World, Bodies = Matter.Bodies, Body = Matter.Body, Composite = Matter.Composite, Events = Matter.Events, Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint, Vector = Matter.Vector;

            // --- Game Variables & Constants ---
            const loadingIndicator = document.getElementById('loading-indicator');
            const uiContainer = document.getElementById('ui-container');
            const canvas = document.getElementById('game-canvas');
            const scoreElement = document.getElementById('score');
            const knivesLeftElement = document.getElementById('knives-left');
            const resetButton = document.getElementById('reset-button');
            const messageBox = document.getElementById('message-box');
            let canvasWidth, canvasHeight;
            const maxCanvasWidth = 800; const aspectRatio = 4 / 3;
            let engine, render, runner, world, mouseConstraint, mouse;
            let score = 0, knivesPerLevel = 4, knivesRemaining = knivesPerLevel, currentLevel = 0;
            let targets = [], movingBodies = [], particles = [], activeKnife = null, isAiming = false, aimStartPosition = null, launchPosition = { x: 0, y: 0 }, trajectoryLine = [];
            let currentWind = { x: 0, y: 0 };
            let windParticles = [];

            // --- Asset Definitions --- (Unchanged)
            const crocImageURL = 'https://i.imgur.com/qUjn2EU_d.png?maxwidth=520&shape=thumb&fidelity=high';
            const knifeImageURL = 'https://i.imgur.com/XePxN34_d.png?maxwidth=520&shape=thumb&fidelity=high';
            const imageUrlsToPreload = [crocImageURL, knifeImageURL];
            const targetCircleSVG = `<svg width="60" height="60" xmlns="http://www.w3.org/2000/svg"><circle cx="30" cy="30" r="28" fill="#FF6347" stroke="#CD5C5C" stroke-width="3"/><circle cx="30" cy="30" r="18" fill="white" stroke="#CD5C5C" stroke-width="2"/><circle cx="30" cy="30" r="8" fill="#FF6347" stroke="#CD5C5C" stroke-width="2"/></svg>`;
            const targetCircleDataURI = 'data:image/svg+xml;base64,' + btoa(targetCircleSVG);
            const targetRectSVG = `<svg width="70" height="70" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="66" height="66" rx="5" fill="#FF6347" stroke="#CD5C5C" stroke-width="3"/><rect x="15" y="15" width="40" height="40" fill="white" stroke="#CD5C5C" stroke-width="2"/><rect x="25" y="25" width="20" height="20" fill="#FF6347" stroke="#CD5C5C" stroke-width="2"/></svg>`;
            const targetRectDataURI = 'data:image/svg+xml;base64,' + btoa(targetRectSVG);
            const crateSVG = `<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="46" height="46" fill="#DEB887" stroke="#8B4513" stroke-width="2"/><line x1="2" y1="2" x2="48" y2="48" stroke="#8B4513" stroke-width="2"/><line x1="48" y1="2" x2="2" y2="48" stroke="#8B4513" stroke-width="2"/><line x1="25" y1="2" x2="25" y2="48" stroke="#8B4513" stroke-width="1.5"/><line x1="2" y1="25" x2="48" y2="25" stroke="#8B4513" stroke-width="1.5"/></svg>`;
            const crateDataURI = 'data:image/svg+xml;base64,' + btoa(crateSVG);

            // --- Level Data --- (Unchanged from previous version)
             const levels = [ { targets: [ { xRel: 0.81, yRel: 0.67, radius: 25, points: 10, type: 'circle' } ], obstacles: [ { xRel: 0.625, yRel: 0.58, width: 20, height: 150, isStatic: true, label: 'obstacle' }, { xRel: 0.45, yRel: 0.70, width: 50, height: 15, isStatic: true, label: 'obstacle' } ], wind: { x: 0, y: 0 } }, { targets: [ { xRel: 0.875, yRel: 0.25, radius: 20, points: 15, type: 'circle', movement: { type: 'vertical', rangeRel: [0.167, 0.5], speed: 2.0 } } ], obstacles: [ { xRel: 0.60, yRel: 0.65, width: 50, height: 50, isStatic: false, label: 'destructible', health: 2, points: 5 }, { xRel: 0.875, yRel: 0.45, width: 100, height: 15, isStatic: true, label: 'obstacle' }, { xRel: 0.65, yRel: 0.15, width: 200, height: 15, isStatic: true, label: 'obstacle' } ], wind: { x: 0.0005, y: 0 } }, { targets: [ { xRel: 0.6875, yRel: 0.25, radius: 20, points: 10, type: 'circle' }, { xRel: 0.9375, yRel: 0.75, radius: 30, points: 20, type: 'circle', movement: { type: 'horizontal', rangeRel: [0.8125, 1.0], speed: 2.5 } } ], obstacles: [ { xRel: 0.5625, yRel: 0.416, width: 150, height: 20, isStatic: true, label: 'obstacle' }, { xRel: 0.8, yRel: 0.65, width: 50, height: 50, isStatic: false, label: 'destructible', health: 3, points: 10 }, { xRel: 0.9, yRel: 0.8, width: 40, height: 40, isStatic: false, label: 'destructible', health: 2, points: 5 } ], wind: { x: -0.0008, y: 0 } } ];

            // --- Initialization Function --- (Unchanged)
            function init() { calculateCanvasSize(); engine = Engine.create(); world = engine.world; world.gravity.y = 0.9; render = Render.create({ canvas: canvas, engine: engine, options: { width: canvasWidth, height: canvasHeight, wireframes: false, background: '#a0d8ef' } }); runner = Runner.create(); mouse = Mouse.create(render.canvas); mouseConstraint = MouseConstraint.create(engine, { mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } } }); mouseConstraint.collisionFilter.mask = 0; World.add(world, mouseConstraint); render.mouse = mouse; launchPosition.x = canvasWidth * 0.1875; launchPosition.y = canvasHeight * 0.75; createWindParticles(15); loadLevel(currentLevel); addEventListeners(); Runner.run(runner, engine); Render.run(render); console.log(`Game Initialized. Canvas: ${canvasWidth}x${canvasHeight}. Level: ${currentLevel}`); /* if (window.Telegram && window.Telegram.WebApp) { window.Telegram.WebApp.ready(); } */ }

            // --- Calculate Canvas Size --- ** MODIFIED: Simplified Height Calc **
            function calculateCanvasSize() {
                // Use available width, respecting max width
                const containerWidth = document.body.clientWidth * 0.95; // Use 95% of body width
                canvasWidth = Math.min(containerWidth, maxCanvasWidth); // Clamp to max width

                // Calculate height based purely on aspect ratio
                canvasHeight = canvasWidth / aspectRatio;

                // Apply size to canvas element (CSS max-height will handle overflow if needed)
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Also set UI container width to match canvas width for alignment
                uiContainer.style.width = canvasWidth + 'px';
            }
            // --- Level Loading Function --- (Unchanged)
            function loadLevel(levelIndex) { World.clear(world); Engine.clear(engine); targets = []; movingBodies = []; particles = []; score = 0; knivesRemaining = knivesPerLevel; activeKnife = null; isAiming = false; trajectoryLine = []; aimStartPosition = null; updateUI(); hideMessage(); const levelData = levels[levelIndex]; if (!levelData) { console.error("Level data not found:", levelIndex); handleGameWin(); return; } currentWind = levelData.wind || { x: 0, y: 0 }; console.log("Current Wind:", currentWind); const groundHeight = 50; const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight - (groundHeight / 2), canvasWidth, groundHeight, { isStatic: true, label: 'ground', render: { fillStyle: '#77dd77' } }); World.add(world, ground); const crocBodyWidth = 50; const crocBodyHeight = 30; const crocRenderXOffset = -15; const crocRenderYOffset = 5; const crocBody = Bodies.rectangle(launchPosition.x + crocRenderXOffset, launchPosition.y + crocRenderYOffset, crocBodyWidth, crocBodyHeight, { isStatic: true, label: 'croc', render: { sprite: { texture: crocImageURL, xScale: 0.7, yScale: 0.7 } } }); World.add(world, crocBody); levelData.targets.forEach(targetData => { let targetBody; let svgURI = targetData.type === 'circle' ? targetCircleDataURI : targetRectDataURI; const targetX = targetData.xRel * canvasWidth; const targetY = targetData.yRel * canvasHeight; const radius = targetData.radius; const width = targetData.width; const height = targetData.height; let bodyRadius = targetData.type === 'circle' ? radius * 0.8 : null; let bodyWidth = targetData.type === 'rectangle' ? width * 0.9 : null; let bodyHeight = targetData.type === 'rectangle' ? height * 0.9 : null; const options = { label: 'target', isStatic: !!targetData.movement, restitution: 0.5, friction: 0.5, customData: { points: targetData.points, movement: targetData.movement ? { type: targetData.movement.type, speed: targetData.movement.speed, range: targetData.movement.rangeRel.map((r, i) => r * (targetData.movement.type === 'horizontal' ? canvasWidth : canvasHeight)) } : null }, render: { sprite: { texture: svgURI, xScale: (radius ? radius * 2 : width) / (targetData.type === 'circle' ? 60 : 70), yScale: (radius ? radius * 2 : height) / (targetData.type === 'circle' ? 60 : 70) } } }; if (targetData.type === 'circle') { targetBody = Bodies.circle(targetX, targetY, bodyRadius, options); } else { targetBody = Bodies.rectangle(targetX, targetY, bodyWidth, bodyHeight, options); } targets.push(targetBody); World.add(world, targetBody); if (options.customData.movement) { movingBodies.push(targetBody); const move = options.customData.movement; if (move.type === 'horizontal') { Body.setVelocity(targetBody, { x: move.speed, y: 0 }); } else if (move.type === 'vertical') { Body.setVelocity(targetBody, { x: 0, y: move.speed }); } } }); if (levelData.obstacles) { levelData.obstacles.forEach(obstacleData => { let obstacleBody; const isDestructible = obstacleData.label === 'destructible'; const obstacleX = obstacleData.xRel * canvasWidth; const obstacleY = obstacleData.yRel * canvasHeight; const width = obstacleData.width; const height = obstacleData.height; const options = { isStatic: obstacleData.isStatic, label: obstacleData.label, friction: 0.9, customData: {}, render: {} }; if (isDestructible) { options.customData.health = obstacleData.health; options.customData.points = obstacleData.points || 0; options.render = { sprite: { texture: crateDataURI, xScale: width / 50, yScale: height / 50 } }; obstacleBody = Bodies.rectangle(obstacleX, obstacleY, width * 0.9, height * 0.9, options); } else { options.render = { fillStyle: '#a0522d' }; obstacleBody = Bodies.rectangle(obstacleX, obstacleY, width, height, options); } World.add(world, obstacleBody); }); } if (!Composite.allConstraints(world).includes(mouseConstraint)) { World.add(world, mouseConstraint); } console.log(`Level ${levelIndex} loaded.`); }
            // --- Helper Function to Get Event Position Relative to Canvas --- (Unchanged)
            function getEventPosition(event) { const rect = canvas.getBoundingClientRect(); let clientX, clientY; if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; } else if (event.changedTouches && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; } else { clientX = event.clientX; clientY = event.clientY; } const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const canvasX = (clientX - rect.left) * scaleX; const canvasY = (clientY - rect.top) * scaleY; return { x: canvasX, y: canvasY }; }
            // --- Aiming Logic Functions --- (Unchanged)
            function handleAimStart(event) { const pos = getEventPosition(event); if (knivesRemaining > 0 && !activeKnife && !isAiming) { const dist = Math.hypot(pos.x - launchPosition.x, pos.y - launchPosition.y); if (dist < 50) { isAiming = true; aimStartPosition = pos; trajectoryLine = []; console.log("Aiming started"); event.preventDefault(); } } }
            function handleAimMove(event) { if (isAiming) { const pos = getEventPosition(event); drawTrajectory(pos); console.log("Aiming move"); event.preventDefault(); } }
            function handleAimEnd(event) { if (isAiming) { isAiming = false; const endPos = getEventPosition(event); launchKnife(endPos); trajectoryLine = []; aimStartPosition = null; console.log("Aiming ended, knife launched"); } }
            // --- Event Listeners --- (Unchanged)
            function addEventListeners() { canvas.addEventListener('mousedown', handleAimStart); canvas.addEventListener('mousemove', handleAimMove); window.addEventListener('mouseup', handleAimEnd); canvas.addEventListener('touchstart', handleAimStart); canvas.addEventListener('touchmove', handleAimMove); canvas.addEventListener('touchend', handleAimEnd); canvas.addEventListener('touchcancel', handleAimEnd); Events.on(engine, 'beforeUpdate', (event) => { if (activeKnife && activeKnife.label === 'knife' && !activeKnife.isStatic) { const windForce = Vector.mult(currentWind, 0.0005); Body.applyForce(activeKnife, activeKnife.position, windForce); } movingBodies.forEach(body => { if (!body.customData || !body.customData.movement) return; const movement = body.customData.movement; const pos = body.position; let vel = body.velocity; if (movement.type === 'horizontal') { if (pos.x < movement.range[0] && vel.x < 0) { Body.setVelocity(body, { x: movement.speed, y: 0 }); } else if (pos.x > movement.range[1] && vel.x > 0) { Body.setVelocity(body, { x: -movement.speed, y: 0 }); } } else if (movement.type === 'vertical') { if (pos.y < movement.range[0] && vel.y < 0) { Body.setVelocity(body, { x: 0, y: movement.speed }); } else if (pos.y > movement.range[1] && vel.y > 0) { Body.setVelocity(body, { x: 0, y: -movement.speed }); } } Body.setAngularVelocity(body, 0); if (movement.type === 'horizontal') Body.setVelocity(body, { x: body.velocity.x, y: 0 }); if (movement.type === 'vertical') Body.setVelocity(body, { x: 0, y: body.velocity.y }); }); particles.forEach((p, index) => { p.life -= 1; p.radius *= 0.98; p.alpha *= 0.97; if (p.life <= 0) { particles.splice(index, 1); } }); windParticles.forEach(wp => { wp.x += currentWind.x * 50 + (Math.random() - 0.5) * 0.5 + wp.driftX; wp.y += currentWind.y * 50 + (Math.random() - 0.5) * 0.5 + wp.driftY; wp.alpha -= 0.002; if (wp.alpha <= 0) { wp.x = Math.random() * canvasWidth; wp.y = Math.random() * canvasHeight; wp.alpha = 0.5 + Math.random() * 0.3; wp.radius = 2 + Math.random() * 3; } else { if (wp.x > canvasWidth + wp.radius) wp.x = -wp.radius; if (wp.x < -wp.radius) wp.x = canvasWidth + wp.radius; if (wp.y > canvasHeight + wp.radius) wp.y = -wp.radius; if (wp.y < -wp.radius) wp.y = canvasHeight + wp.radius; } }); }); Events.on(render, 'afterRender', () => { const context = render.context; if (trajectoryLine.length > 0) { context.beginPath(); context.moveTo(trajectoryLine[0].x, trajectoryLine[0].y); for (let i = 1; i < trajectoryLine.length; i++) { context.lineTo(trajectoryLine[i].x, trajectoryLine[i].y); } context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; context.lineWidth = 3; context.setLineDash([8, 6]); context.stroke(); context.setLineDash([]); } particles.forEach(p => { context.beginPath(); context.arc(p.x, p.y, p.radius, 0, Math.PI * 2); context.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha})`; context.fill(); }); windParticles.forEach(wp => { context.beginPath(); context.arc(wp.x, wp.y, wp.radius, 0, Math.PI * 2); context.fillStyle = `rgba(255, 255, 255, ${wp.alpha * 0.5})`; context.fill(); }); }); Events.on(engine, 'collisionStart', (event) => { const pairs = event.pairs; pairs.forEach(pair => { const bodyA = pair.bodyA; const bodyB = pair.bodyB; let knifeBody = null; let otherBody = null; if (bodyA.label === 'knife' || bodyA.label === 'stuck_knife') { knifeBody = bodyA; otherBody = bodyB; } else if (bodyB.label === 'knife' || bodyB.label === 'stuck_knife') { knifeBody = bodyB; otherBody = bodyA; } if (!knifeBody || knifeBody.label === 'stuck_knife') return; if (otherBody.label === 'target') { if (otherBody.render.visible) { handleTargetHit(otherBody, knifeBody); } } else if (otherBody.label === 'destructible') { handleDestructibleHit(otherBody, knifeBody); } else if (otherBody.label === 'obstacle' || otherBody.label === 'ground') { handleKnifeStick(knifeBody); } }); }); resetButton.addEventListener('click', () => { loadLevel(currentLevel); }); }

            // --- Game Logic Functions --- (Unchanged)
            function launchKnife(endPos) { if (knivesRemaining <= 0 || !aimStartPosition) return; knivesRemaining--; updateUI(); const dx = aimStartPosition.x - endPos.x; const dy = aimStartPosition.y - endPos.y; const distance = Math.hypot(dx, dy); const maxPower = 80; const powerScale = 0.35; const power = Math.min(distance / 4, maxPower) * powerScale; const angle = Math.atan2(dy, dx); const knifeBodyWidth = 30; const knifeBodyHeight = 10; activeKnife = Bodies.rectangle(launchPosition.x, launchPosition.y, knifeBodyWidth, knifeBodyHeight, { label: 'knife', frictionAir: 0.015, density: 0.01, render: { sprite: { texture: knifeImageURL, xScale: 0.30, yScale: 0.30 } } }); World.add(world, activeKnife); Body.setVelocity(activeKnife, { x: Math.cos(angle) * power, y: Math.sin(angle) * power }); Body.setAngularVelocity(activeKnife, 0.15 * (Math.random() < 0.5 ? 1 : -1)); setTimeout(() => { if (activeKnife && activeKnife.label === 'knife') { activeKnife = null; } }, 1000); }
            function drawTrajectory(currentPos) { if (!aimStartPosition) return; trajectoryLine = []; const startX = launchPosition.x; const startY = launchPosition.y; const dx = aimStartPosition.x - currentPos.x; const dy = aimStartPosition.y - currentPos.y; const distance = Math.hypot(dx, dy); const maxPower = 80; const powerScale = 0.35; const power = Math.min(distance / 4, maxPower) * powerScale; const angle = Math.atan2(dy, dx); let tempX = startX; let tempY = startY; let velX = Math.cos(angle) * power; let velY = Math.sin(angle) * power; const timeStep = 0.1; const gravity = world.gravity.y * engine.timing.timeScale * timeStep * timeStep * 10; const airFriction = 1 - (0.015 * timeStep * 10); const trajectoryPoints = 40; for (let i = 0; i < trajectoryPoints; i++) { trajectoryLine.push({ x: tempX, y: tempY }); tempX += velX * timeStep * 10; tempY += velY * timeStep * 10; velY += gravity; velX *= airFriction; velY *= airFriction; if (tempY > canvasHeight + 50 || tempY < -50 || tempX < -50 || tempX > canvasWidth + 50) break; } }
            function handleTargetHit(targetBody, knifeBody) { console.log("Target Hit!"); score += targetBody.customData.points || 10; createParticles(targetBody.position.x, targetBody.position.y, 7, { r: 255, g: 255, b: 0 }); /* Consider Telegram Haptic: Telegram.WebApp.HapticFeedback.impactOccurred('medium'); */ targetBody.render.visible = false; setTimeout(() => World.remove(world, targetBody), 50); targets = targets.filter(t => t !== targetBody); movingBodies = movingBodies.filter(mb => mb !== targetBody); handleKnifeStick(knifeBody); updateUI(); if (targets.length === 0) { levelComplete(); } }
            function handleDestructibleHit(obstacleBody, knifeBody) { if (!obstacleBody.customData) return; obstacleBody.customData.health -= 1; console.log(`Destructible hit! Health: ${obstacleBody.customData.health}`); createParticles(knifeBody.position.x, knifeBody.position.y, 3, { r: 139, g: 69, b: 19 }); /* Consider Telegram Haptic: Telegram.WebApp.HapticFeedback.impactOccurred('light'); */ if (obstacleBody.customData.health <= 0) { console.log("Destructible destroyed!"); score += obstacleBody.customData.points || 0; createParticles(obstacleBody.position.x, obstacleBody.position.y, 10, { r: 139, g: 69, b: 19 }); /* Consider Telegram Haptic: Telegram.WebApp.HapticFeedback.impactOccurred('heavy'); */ obstacleBody.render.visible = false; setTimeout(() => World.remove(world, obstacleBody), 50); updateUI(); } handleKnifeStick(knifeBody); }
            function handleKnifeStick(knifeBody) { if (knifeBody.label !== 'stuck_knife') { knifeBody.label = 'stuck_knife'; Body.setStatic(knifeBody, true); Body.setAngularVelocity(knifeBody, 0); console.log("Knife stuck"); if (activeKnife === knifeBody) { activeKnife = null; } } }
            function createParticles(x, y, count, color) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 3 + 1; const particle = { x: x, y: y, radius: Math.random() * 4 + 2, color: color, life: 30 + Math.random() * 20, alpha: 0.9, }; particles.push(particle); } }
            function createWindParticles(count) { for (let i = 0; i < count; i++) { windParticles.push({ x: Math.random() * canvasWidth, y: Math.random() * canvasHeight, radius: 2 + Math.random() * 3, alpha: 0.5 + Math.random() * 0.3, driftX: (Math.random() - 0.5) * 0.2, driftY: (Math.random() - 0.5) * 0.2 }); } }
            function updateUI() { scoreElement.textContent = `Score: ${score}`; knivesLeftElement.textContent = `Knives: ${knivesRemaining}`; if (knivesRemaining <= 0 && targets.some(t => t.render.visible) && !isAiming && activeKnife === null) { setTimeout(() => { if (knivesRemaining <= 0 && targets.some(t => t.render.visible)) { gameOver(); } }, 1500); } }
            // --- Game State Functions --- (Unchanged)
            function levelComplete() { console.log("Level Complete!"); if (currentLevel < levels.length - 1) { showMessage(`Level ${currentLevel + 1} Complete!<br>Score: ${score}`); } currentLevel++; setTimeout(() => { if (currentLevel >= levels.length) { handleGameWin(); } else { loadLevel(currentLevel); } }, 1500); }
            function gameOver() { console.log("Game Over!"); showMessage("<h2>Game Over!</h2><p>Try Again!</p>"); }
            function generatePrizeCode() { const timestamp = Date.now(); let randomLetters = ''; const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; for (let i = 0; i < 4; i++) { randomLetters += characters.charAt(Math.floor(Math.random() * characters.length)); } return `PRIZE-${timestamp}-${randomLetters}`; }
            function handleGameWin() { console.log("Game Won!"); const prizeCode = generatePrizeCode(); const xComposeUrl = `https://x.com/compose/post`; const winMessageHTML = `<h2>🎉 Congratulations! You won! 🎉</h2><p>Your code: <span class="prize-code">${prizeCode}</span></p><div class="instructions"><p><strong>Instructions:</strong></p><p>1. Create a post about $STAB on X and tag @croc_with_knife.</p><p>2. Then DM @croc_with_knife the code.</p></div><a href="${xComposeUrl}" target="_blank" rel="noopener noreferrer"><button>Create Post on X</button></a>`; showMessage(winMessageHTML); }
            function showMessage(htmlContent) { messageBox.innerHTML = htmlContent; messageBox.style.display = 'block'; }
            function hideMessage() { messageBox.style.display = 'none'; }

            // --- Preloading Logic --- (Unchanged)
            function preloadAssets(urls, callback) { let loadedCount = 0; let errorCount = 0; const totalAssets = urls.length; if (totalAssets === 0) { callback(); return; } loadingIndicator.style.display = 'flex'; urls.forEach(url => { const img = new Image(); img.onload = () => { loadedCount++; console.log(`Loaded: ${url}`); if (loadedCount + errorCount === totalAssets) { callback(); } }; img.onerror = () => { errorCount++; console.error(`Error loading: ${url}`); if (loadedCount + errorCount === totalAssets) { callback(); } }; img.src = url; }); }

            // --- Start Game Function --- (Unchanged)
            function startGame() { loadingIndicator.style.display = 'none'; uiContainer.style.display = 'flex'; canvas.style.display = 'block'; init(); }

            // --- Start Preloading --- ** MODIFIED: Added slight delay **
            // Delay allows Telegram webview to potentially settle dimensions
            setTimeout(() => {
                preloadAssets(imageUrlsToPreload, startGame);
            }, 100); // 100ms delay

        } // End of setupGame function

        // Call the main setup function when DOM is ready
        document.addEventListener('DOMContentLoaded', setupGame);

    </script>

</body>
</html>
