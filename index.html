<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Croc Knives - Compatible!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">

    <style>
        /* Basic Reset & Body Styles */
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
            background: #a0d8ef; /* Simple background */
            font-family: 'Arial', sans-serif; /* Fallback font */
            color: #333;
            box-sizing: border-box;
        }
        *, *:before, *:after { box-sizing: inherit; }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }

        /* UI Container Styles */
        #ui-container {
            display: flex; /* Use flexbox carefully */
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            max-width: 800px; /* Limit max width */
            padding: 8px;
            margin-bottom: 10px;
            background: #4caf50; /* Green background */
            color: white;
            border-radius: 8px;
            font-family: 'Luckiest Guy', cursive; /* Use fun font here */
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
            flex-shrink: 0;
        }
        .ui-element {
            font-size: 1.2em; /* Slightly smaller base */
            margin: 4px 8px;
        }
        #reset-button {
            padding: 6px 12px;
            font-size: 0.9em;
            font-family: 'Luckiest Guy', cursive;
            color: white;
            background: #f44336; /* Red */
            border: 1px solid #d32f2f;
            border-radius: 5px;
            cursor: pointer;
            margin: 4px;
        }
        #reset-button:hover { background: #d32f2f; }

        /* Canvas Styles */
        canvas {
            display: block;
            border: 3px solid #5c3d21; /* Brown border */
            border-radius: 8px;
            background: #e0f7fa; /* Light cyan background */
            max-width: 100%;
            max-height: 100%;
            /* Prevent touch actions */
             touch-action: none;
            -ms-touch-action: none; /* IE specific */
        }

        /* Message Box Styles */
        #message-box {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            width: 80%; max-width: 450px;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.1em;
            text-align: center;
            display: none;
            z-index: 10;
            border: 2px solid #fdd835; /* Gold border */
            font-family: 'Luckiest Guy', cursive;
            line-height: 1.5;
        }
         #message-box h2 { font-size: 1.4em; color: #fdd835; margin-top: 0; margin-bottom: 10px; }
         #message-box p { margin: 8px 0; }
         #message-box strong { color: #fdd835; }
         #message-box .prize-code { display: inline-block; background-color: rgba(255, 255, 255, 0.1); padding: 3px 8px; border-radius: 4px; font-size: 1em; color: #fff; margin: 5px 0; word-break: break-all; font-family: monospace; }
         #message-box .instructions { font-size: 0.85em; opacity: 0.9; margin-top: 15px; }
         #message-box button { display: inline-block; padding: 10px 18px; font-size: 0.9em; font-family: 'Luckiest Guy', cursive; color: white; background: #1DA1F2; border: 1px solid #0c85d0; border-radius: 6px; cursor: pointer; margin-top: 15px; text-decoration: none; }
         #message-box button:hover { background: #0c85d0; }

    </style>
</head>
<body>
    <div id="ui-container">
        <div id="score" class="ui-element">Score: 0</div>
        <div id="knives-left" class="ui-element">Knives: 4</div>
        <button id="reset-button">Reset Level</button>
    </div>

    <canvas id="game-canvas"></canvas>
    <div id="message-box"></div>

    <script>
        // Wrap in IIFE for scope protection
        (function() {
            'use strict'; // Enable strict mode

            // --- Game Variables ---
            var canvas, ctx;
            var scoreElement, knivesLeftElement, resetButton, messageBox;
            var canvasWidth, canvasHeight;
            var maxCanvasWidth = 800; var aspectRatio = 4 / 3;
            var score = 0, knivesPerLevel = 4, knivesRemaining = knivesPerLevel, currentLevel = 0;
            var isAiming = false, aimStartPosition = null, aimEndPosition = null;
            var launchPosition = { x: 0, y: 0 };
            var trajectoryLine = [];
            var gravity = 0.2; // Simplified gravity value for manual physics
            var groundHeight = 30; // Simplified ground height for drawing

            // Game Objects Arrays
            var knivesInAir = [];
            var targets = [];
            var obstacles = [];
            var croc = { x: 0, y: 0, width: 50, height: 30, renderXOffset: -15, renderYOffset: 5 };

            // --- Asset Definitions (SVGs as Data URIs) ---
            var crocSVG = '<svg width="50" height="30" viewBox="0 0 50 30" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="10" width="44" height="18" rx="9" fill="#3CB371" stroke="#2E8B57" stroke-width="1.5"/><ellipse cx="40" cy="10" rx="7" ry="5" fill="#3CB371" stroke="#2E8B57" stroke-width="1.5"/><circle cx="42" cy="8" r="1.5" fill="black"/><rect x="7" y="28" width="10" height="5" fill="#3CB371" stroke="#2E8B57" stroke-width="1"/><rect x="23" y="28" width="10" height="5" fill="#3CB371" stroke="#2E8B57" stroke-width="1"/></svg>';
            var crocDataURI = 'data:image/svg+xml;base64,' + btoa(crocSVG);
            var crocImage = new Image(); // Preload SVG image for drawing

            var knifeSVG = '<svg width="30" height="10" viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg"><polygon points="0,5 22,0 28,5 22,10" fill="#B0C4DE" stroke="#708090" stroke-width="1"/><rect x="25" y="3" width="5" height="4" fill="#8B4513" stroke="#5c3d21" stroke-width="0.5"/></svg>';
            var knifeDataURI = 'data:image/svg+xml;base64,' + btoa(knifeSVG);
            var knifeImage = new Image(); // Preload SVG image

            var targetCircleSVG = '<svg width="60" height="60" xmlns="http://www.w3.org/2000/svg"><circle cx="30" cy="30" r="28" fill="#FF6347" stroke="#CD5C5C" stroke-width="3"/><circle cx="30" cy="30" r="18" fill="white" stroke="#CD5C5C" stroke-width="2"/><circle cx="30" cy="30" r="8" fill="#FF6347" stroke="#CD5C5C" stroke-width="2"/></svg>';
            var targetCircleDataURI = 'data:image/svg+xml;base64,' + btoa(targetCircleSVG);
            var targetCircleImage = new Image();

            var targetRectSVG = '<svg width="70" height="70" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="66" height="66" rx="5" fill="#FF6347" stroke="#CD5C5C" stroke-width="3"/><rect x="15" y="15" width="40" height="40" fill="white" stroke="#CD5C5C" stroke-width="2"/><rect x="25" y="25" width="20" height="20" fill="#FF6347" stroke="#CD5C5C" stroke-width="2"/></svg>';
            var targetRectDataURI = 'data:image/svg+xml;base64,' + btoa(targetRectSVG);
            var targetRectImage = new Image();

            var crateSVG = '<svg width="50" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="46" height="46" fill="#DEB887" stroke="#8B4513" stroke-width="2"/><line x1="2" y1="2" x2="48" y2="48" stroke="#8B4513" stroke-width="2"/><line x1="48" y1="2" x2="2" y2="48" stroke="#8B4513" stroke-width="2"/><line x1="25" y1="2" x2="25" y2="48" stroke="#8B4513" stroke-width="1.5"/><line x1="2" y1="25" x2="48" y2="25" stroke="#8B4513" stroke-width="1.5"/></svg>';
            var crateDataURI = 'data:image/svg+xml;base64,' + btoa(crateSVG);
            var crateImage = new Image();

            // Simple asset loader
            var assets = [
                { img: crocImage, src: crocDataURI },
                { img: knifeImage, src: knifeDataURI },
                { img: targetCircleImage, src: targetCircleDataURI },
                { img: targetRectImage, src: targetRectDataURI },
                { img: crateImage, src: crateDataURI }
            ];
            var assetsLoaded = 0;
            var totalAssets = assets.length;

            function assetLoaded() {
                assetsLoaded++;
                if (assetsLoaded === totalAssets) {
                    console.log("All assets loaded, starting game.");
                    init(); // Start game only after images are loaded
                }
            }

            function loadAssets() {
                 console.log("Loading assets...");
                 if (totalAssets === 0) {
                     init();
                     return;
                 }
                 assets.forEach(function(asset) {
                     asset.img.onload = assetLoaded;
                     asset.img.onerror = function() {
                         console.error("Error loading asset:", asset.src);
                         assetLoaded(); // Count error as loaded to prevent hanging
                     };
                     asset.img.src = asset.src;
                 });
            }

            // --- Level Data --- (Simplified, positions calculated in loadLevel)
             var levels = [
                // Level 0
                {
                    targets: [ { type: 'circle', xRel: 0.81, yRel: 0.67, radius: 25, points: 10 } ],
                    obstacles: [ { type: 'rect', xRel: 0.625, yRel: 0.58, width: 20, height: 150, label: 'obstacle' },
                                 { type: 'rect', xRel: 0.45, yRel: 0.70, width: 50, height: 15, label: 'obstacle' } ]
                },
                // Level 1
                {
                    targets: [ { type: 'circle', xRel: 0.875, yRel: 0.25, radius: 20, points: 15, movement: { type: 'vertical', rangeRel: [0.167, 0.5], speed: 1.0 } } ], // Slower speed
                    obstacles: [ { type: 'crate', xRel: 0.60, yRel: 0.65, width: 50, height: 50, health: 2, points: 5 },
                                 { type: 'rect', xRel: 0.875, yRel: 0.45, width: 100, height: 15, label: 'obstacle' },
                                 { type: 'rect', xRel: 0.65, yRel: 0.15, width: 200, height: 15, label: 'obstacle' } ]
                },
                // Level 2
                {
                    targets: [ { type: 'circle', xRel: 0.6875, yRel: 0.25, radius: 20, points: 10 },
                               { type: 'circle', xRel: 0.9375, yRel: 0.75, radius: 30, points: 20, movement: { type: 'horizontal', rangeRel: [0.8125, 1.0], speed: 1.2 } } ], // Slower speed
                    obstacles: [ { type: 'rect', xRel: 0.5625, yRel: 0.416, width: 150, height: 20, label: 'obstacle' },
                                 { type: 'crate', xRel: 0.75, yRel: 0.65, width: 50, height: 50, health: 3, points: 10 },
                                 { type: 'crate', xRel: 0.9, yRel: 0.8, width: 40, height: 40, health: 2, points: 5 } ]
                }
            ];

            // --- Initialization Function ---
            function init() {
                canvas = document.getElementById('game-canvas');
                ctx = canvas.getContext('2d');
                scoreElement = document.getElementById('score');
                knivesLeftElement = document.getElementById('knives-left');
                resetButton = document.getElementById('reset-button');
                messageBox = document.getElementById('message-box');

                calculateCanvasSize(); // Initial size calculation
                loadLevel(currentLevel);
                addEventListeners();

                // Start game loop
                gameLoop();

                console.log("Game Initialized.");
                window.addEventListener('resize', handleResizeDebounced);
            }

            // --- Calculate Canvas Size --- (Simplified, uses window dimensions)
            function calculateCanvasSize() {
                var padding = 20;
                var uiHeightEst = uiContainer.offsetHeight || 60;
                var availableWidth = window.innerWidth - padding;
                var availableHeight = window.innerHeight - padding - uiHeightEst;

                var targetWidth = availableWidth;
                var targetHeight = targetWidth / aspectRatio;

                if (targetHeight > availableHeight) {
                    targetHeight = availableHeight;
                    targetWidth = targetHeight * aspectRatio;
                }

                canvasWidth = Math.min(targetWidth, maxCanvasWidth);
                canvasHeight = canvasWidth / aspectRatio;

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                uiContainer.style.width = canvasWidth + 'px';

                // Calculate launch position based on final canvas size
                launchPosition.x = canvasWidth * 0.1875;
                launchPosition.y = canvasHeight - groundHeight - (croc.height / 2) - 5; // Place near ground

                // Update croc position object
                croc.x = launchPosition.x + croc.renderXOffset;
                croc.y = launchPosition.y + croc.renderYOffset;

                console.log("Calculated Size:", canvasWidth, canvasHeight);
            }

            // --- Level Loading Function --- (Uses manual object structure)
            function loadLevel(levelIndex) {
                // Clear existing objects
                targets = []; obstacles = []; knivesInAir = []; particles = [];
                score = 0; knivesRemaining = knivesPerLevel;
                activeKnife = null; isAiming = false; trajectoryLine = []; aimStartPosition = null;
                updateUI(); hideMessage();

                var levelData = levels[levelIndex];
                if (!levelData) { console.error("Level data not found:", levelIndex); handleGameWin(); return; }

                // Load Targets
                levelData.targets.forEach(function(tData) {
                    var target = {
                        type: tData.type,
                        x: tData.xRel * canvasWidth,
                        y: tData.yRel * canvasHeight,
                        radius: tData.radius, // Keep radius for circle targets
                        width: tData.radius ? tData.radius * 2 : (tData.width || 60), // Use radius or defined width
                        height: tData.radius ? tData.radius * 2 : (tData.height || 60), // Use radius or defined height
                        points: tData.points,
                        img: tData.type === 'circle' ? targetCircleImage : targetRectImage,
                        active: true, // Flag to check if target is hit
                        movement: null
                    };
                    // Adjust width/height based on image aspect ratio if needed later
                    target.drawWidth = target.width; // Size to draw image
                    target.drawHeight = target.height;

                    if (tData.movement) {
                        target.movement = {
                            type: tData.movement.type,
                            speed: tData.movement.speed,
                            range: tData.movement.rangeRel.map(function(r, i) {
                                return r * (tData.movement.type === 'horizontal' ? canvasWidth : canvasHeight);
                            }),
                            direction: 1 // 1 for positive, -1 for negative
                        };
                        // Set initial velocity based on movement type
                         target.vx = (target.movement.type === 'horizontal') ? target.movement.speed * target.movement.direction : 0;
                         target.vy = (target.movement.type === 'vertical') ? target.movement.speed * target.movement.direction : 0;
                    } else {
                         target.vx = 0;
                         target.vy = 0;
                    }
                    targets.push(target);
                });

                // Load Obstacles
                if (levelData.obstacles) {
                    levelData.obstacles.forEach(function(oData) {
                        var obstacle = {
                            type: oData.type,
                            label: oData.label,
                            x: oData.xRel * canvasWidth,
                            y: oData.yRel * canvasHeight,
                            width: oData.width,
                            height: oData.height,
                            health: oData.health || Infinity, // Destructible or static
                            points: oData.points || 0,
                            img: oData.type === 'crate' ? crateImage : null, // Use image only for crates
                            color: oData.type === 'rect' ? '#a0522d' : null, // Color for simple rects
                            active: true
                        };
                         obstacle.drawWidth = obstacle.width;
                         obstacle.drawHeight = obstacle.height;
                        obstacles.push(obstacle);
                    });
                }
                console.log("Level", levelIndex, "loaded.");
            }

            // --- Game Loop ---
            var lastTime = 0;
            function gameLoop(timestamp) {
                var deltaTime = (timestamp - lastTime) / 16.667; // Normalize to 60fps equivalent time step
                if (isNaN(deltaTime) || deltaTime > 2) { // Prevent large jumps on first frame or lag
                    deltaTime = 1;
                }
                lastTime = timestamp;

                update(deltaTime);
                renderFrame();

                requestAnimationFrame(gameLoop);
            }

            // --- Update Function ---
            function update(dt) {
                // Update knives in air
                for (var i = knivesInAir.length - 1; i >= 0; i--) {
                    var knife = knivesInAir[i];
                    knife.vy += gravity * dt; // Apply gravity
                    knife.x += knife.vx * dt;
                    knife.y += knife.vy * dt;
                    // Basic rotation based on vertical velocity (optional visual flair)
                    knife.angle += knife.vy * 0.02 * dt;

                    // Check boundaries (remove if off-screen)
                    if (knife.y > canvasHeight + 50 || knife.x < -50 || knife.x > canvasWidth + 50) {
                        knivesInAir.splice(i, 1);
                        console.log("Knife removed (out of bounds)");
                        continue;
                    }
                     // Check collision with ground
                     if (knife.y + knife.height / 2 > canvasHeight - groundHeight) {
                         knife.active = false; // Mark as inactive/stuck
                         knife.y = canvasHeight - groundHeight - knife.height / 2; // Place on ground
                         knife.vx = 0;
                         knife.vy = 0;
                         // knivesInAir.splice(i, 1); // Or just mark inactive
                         console.log("Knife stuck on ground");
                     }
                }

                 // Update moving targets
                 targets.forEach(function(target) {
                     if (target.movement && target.active) {
                         target.x += target.vx * dt;
                         target.y += target.vy * dt;
                         // Check movement boundaries
                         var move = target.movement;
                         if (move.type === 'horizontal') {
                             if ((target.x < move.range[0] && move.direction < 0) || (target.x > move.range[1] && move.direction > 0)) {
                                 move.direction *= -1; // Reverse direction
                                 target.vx = move.speed * move.direction;
                             }
                         } else if (move.type === 'vertical') {
                             if ((target.y < move.range[0] && move.direction < 0) || (target.y > move.range[1] && move.direction > 0)) {
                                 move.direction *= -1; // Reverse direction
                                 target.vy = move.speed * move.direction;
                             }
                         }
                     }
                 });


                // Check collisions
                checkCollisions();

                 // Update particles
                 particles.forEach(function(p, index) {
                    p.life -= 1 * dt;
                    p.radius *= (1 - 0.02 * dt); // Shrink based on dt
                    p.alpha *= (1 - 0.03 * dt); // Fade based on dt
                    if (p.life <= 0 || p.radius < 0.5) {
                        particles.splice(index, 1);
                    }
                 });
            }

            // --- Collision Detection --- (Simple Rect Overlap)
            function checkCollisions() {
                for (var i = knivesInAir.length - 1; i >= 0; i--) {
                    var knife = knivesInAir[i];
                    if (!knife.active) continue; // Skip inactive/stuck knives

                    var knifeRect = { x: knife.x - knife.width / 2, y: knife.y - knife.height / 2, width: knife.width, height: knife.height };

                    // Check against targets
                    for (var j = targets.length - 1; j >= 0; j--) {
                        var target = targets[j];
                        if (!target.active) continue;
                        var targetRect = { x: target.x - target.width / 2, y: target.y - target.height / 2, width: target.width, height: target.height };

                        if (rectsOverlap(knifeRect, targetRect)) {
                            handleTargetHit(target, knife);
                            if (!knife.active) break; // Stop checking this knife if it got stuck
                        }
                    }
                     if (!knife.active) continue; // Re-check if knife got stuck hitting a target

                    // Check against obstacles
                    for (var k = obstacles.length - 1; k >= 0; k--) {
                         var obstacle = obstacles[k];
                         if (!obstacle.active) continue;
                         var obsRect = { x: obstacle.x - obstacle.width / 2, y: obstacle.y - obstacle.height / 2, width: obstacle.width, height: obstacle.height };

                         if (rectsOverlap(knifeRect, obsRect)) {
                             if (obstacle.label === 'destructible') {
                                 handleDestructibleHit(obstacle, knife);
                             } else {
                                 handleKnifeStick(knife); // Stick to static obstacles
                             }
                             if (!knife.active) break; // Stop checking this knife if it got stuck
                         }
                    }
                }
            }

            function rectsOverlap(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }


            // --- Rendering Function ---
            function renderFrame() {
                // Clear canvas
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                // Draw background elements (e.g., simple ground)
                ctx.fillStyle = '#77dd77'; // Green grass color
                ctx.fillRect(0, canvasHeight - groundHeight, canvasWidth, groundHeight);

                // Draw obstacles
                obstacles.forEach(function(obs) {
                    if (!obs.active) return;
                    ctx.save();
                    // Center drawing around object x,y
                    ctx.translate(obs.x, obs.y);
                    if (obs.img) {
                         ctx.drawImage(obs.img, -obs.drawWidth / 2, -obs.drawHeight / 2, obs.drawWidth, obs.drawHeight);
                         // Optional: Draw health indicator on crates
                         if (obs.label === 'destructible' && obs.health < Infinity && obs.health > 0) {
                             ctx.fillStyle = 'rgba(255,0,0,0.6)';
                             ctx.fillRect(-obs.drawWidth/2, obs.drawHeight/2 + 2, obs.drawWidth * (obs.health / (levels[currentLevel].obstacles.find(function(o){return o.xRel === obs.x/canvasWidth && o.yRel === obs.y/canvasHeight;})?.health || 2)), 5); // Rough health bar
                         }
                    } else {
                        ctx.fillStyle = obs.color || '#a0522d'; // Use defined color or default brown
                        ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
                    }
                    ctx.restore();
                });

                // Draw targets
                targets.forEach(function(target) {
                    if (!target.active) return;
                    ctx.save();
                    ctx.translate(target.x, target.y);
                     // Draw target image centered
                    ctx.drawImage(target.img, -target.drawWidth / 2, -target.drawHeight / 2, target.drawWidth, target.drawHeight);
                    ctx.restore();
                });

                // Draw Crocodile
                ctx.save();
                ctx.translate(croc.x, croc.y);
                ctx.drawImage(crocImage, -croc.width / 2, -croc.height / 2, croc.width, croc.height);
                ctx.restore();

                // Draw knives in air
                knivesInAir.forEach(function(knife) {
                    ctx.save();
                    ctx.translate(knife.x, knife.y);
                    ctx.rotate(knife.angle); // Apply rotation
                    // Draw knife image centered
                    ctx.drawImage(knifeImage, -knife.drawWidth / 2, -knife.drawHeight / 2, knife.drawWidth, knife.drawHeight);
                    ctx.restore();
                });

                // Draw trajectory line
                if (isAiming && trajectoryLine.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(trajectoryLine[0].x, trajectoryLine[0].y);
                    for (var i = 1; i < trajectoryLine.length; i++) {
                        ctx.lineTo(trajectoryLine[i].x, trajectoryLine[i].y);
                    }
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // Darker line
                    ctx.lineWidth = 2;
                    // Dashed line effect (check browser compatibility if needed)
                    if (ctx.setLineDash) {
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]); // Reset
                    } else {
                        ctx.stroke(); // Fallback for older browsers
                    }
                }

                 // Draw hit particles
                 particles.forEach(function(p) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(' + p.color.r + ',' + p.color.g + ',' + p.color.b + ',' + p.alpha + ')';
                    ctx.fill();
                 });
            }

            // --- Helper Function to Get Event Position --- (Simplified, basic compatibility)
            function getEventPosition(event) {
                var rect = canvas.getBoundingClientRect();
                var clientX, clientY;
                if (event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX; clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                     clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY;
                } else {
                    clientX = event.clientX; clientY = event.clientY;
                }
                if (clientX === undefined || clientY === undefined) return null;

                var scaleX = canvas.width / rect.width;
                var scaleY = canvas.height / rect.height;
                var canvasX = (clientX - rect.left) * scaleX;
                var canvasY = (clientY - rect.top) * scaleY;
                return { x: canvasX, y: canvasY };
            }

            // --- Aiming Logic Functions ---
            function handleAimStart(event) {
                var pos = getEventPosition(event);
                if (!pos) return;
                if (knivesRemaining > 0 && !activeKnife && !isAiming) {
                    var dist = Math.sqrt(Math.pow(pos.x - launchPosition.x, 2) + Math.pow(pos.y - launchPosition.y, 2));
                    if (dist < 60) { // Aiming area check
                        isAiming = true;
                        aimStartPosition = pos;
                        trajectoryLine = [];
                        console.log("Aiming started");
                        if (event.preventDefault) event.preventDefault(); // Prevent scroll on touch
                    }
                }
            }

            function handleAimMove(event) {
                if (isAiming) {
                    var pos = getEventPosition(event);
                    if (!pos) return;
                    aimEndPosition = pos; // Store current position for trajectory
                    drawTrajectory(aimEndPosition);
                    if (event.preventDefault) event.preventDefault();
                }
            }

            function handleAimEnd(event) {
                if (isAiming) {
                    isAiming = false;
                    // Use the last position recorded during move, or current if no move happened
                    var endPos = aimEndPosition || aimStartPosition;
                    if (endPos) {
                         console.log("Aim end, launching knife");
                         launchKnife(endPos);
                    } else {
                         console.error("Aim end error: No position data.");
                    }
                    trajectoryLine = [];
                    aimStartPosition = null;
                    aimEndPosition = null;
                }
            }

            // --- Debounced Resize Handler ---
            function handleResize() {
                console.log("Resize detected");
                calculateCanvasSize();
                // Reload level to reset positions based on new size
                loadLevel(currentLevel);
            }
            function debounce(func, wait) { var timeout; return function() { var context = this, args = arguments; var later = function() { timeout = null; func.apply(context, args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }
            var handleResizeDebounced = debounce(handleResize, 250);

            // --- Event Listeners --- (Using basic addEventListener)
            function addEventListeners() {
                canvas.addEventListener('mousedown', handleAimStart, false);
                canvas.addEventListener('mousemove', handleAimMove, false);
                window.addEventListener('mouseup', handleAimEnd, false); // Mouseup on window

                // Basic touch support
                canvas.addEventListener('touchstart', handleAimStart, false);
                canvas.addEventListener('touchmove', handleAimMove, false);
                window.addEventListener('touchend', handleAimEnd, false); // Touchend on window
                window.addEventListener('touchcancel', handleAimEnd, false); // Touchcancel on window

                resetButton.addEventListener('click', function() { loadLevel(currentLevel); }, false);
                console.log("Event listeners added.");
            }

            // --- Game Logic Functions ---
            function launchKnife(endPos) {
                if (knivesRemaining <= 0 || !aimStartPosition) return;
                knivesRemaining--; updateUI();

                var dx = aimStartPosition.x - endPos.x;
                var dy = aimStartPosition.y - endPos.y;
                var distance = Math.sqrt(dx*dx + dy*dy);
                var maxPower = 15; // Adjusted power scale for manual physics
                var powerScale = 0.1;
                var power = Math.min(distance * powerScale, maxPower);
                var angle = Math.atan2(dy, dx);

                var knife = {
                    x: launchPosition.x + 15, // Adjusted spawn point
                    y: launchPosition.y - 10,
                    width: 30, height: 10, // Match SVG viewbox roughly
                    drawWidth: 30, drawHeight: 10, // Draw size
                    vx: Math.cos(angle) * power,
                    vy: Math.sin(angle) * power,
                    angle: 0, // Initial angle
                    img: knifeImage,
                    active: true
                };
                knivesInAir.push(knife);
                console.log("Knife launched:", knife.vx, knife.vy);
            }

            function drawTrajectory(currentPos) {
                 if (!aimStartPosition) return;
                 trajectoryLine = [];
                 var startX = launchPosition.x + 15; // Match knife spawn
                 var startY = launchPosition.y - 10;

                 var dx = aimStartPosition.x - currentPos.x;
                 var dy = aimStartPosition.y - currentPos.y;
                 var distance = Math.sqrt(dx*dx + dy*dy);
                 var maxPower = 15; var powerScale = 0.1;
                 var power = Math.min(distance * powerScale, maxPower);
                 var angle = Math.atan2(dy, dx);

                 var tempX = startX; var tempY = startY;
                 var velX = Math.cos(angle) * power; var velY = Math.sin(angle) * power;
                 var timeStep = 1; // Simulate steps for trajectory points

                 // Shorter trajectory line
                 for (var i = 0; i < 30; i++) { // Reduced points
                     trajectoryLine.push({ x: tempX, y: tempY });
                     velY += gravity * timeStep; // Apply gravity for prediction
                     tempX += velX * timeStep;
                     tempY += velY * timeStep;
                     // Basic boundary check for prediction
                     if (tempY > canvasHeight || tempX < 0 || tempX > canvasWidth) break;
                 }
            }

            function handleTargetHit(target, knife) {
                 console.log("Target Hit!");
                 score += target.points || 10;
                 createParticles(target.x, target.y, 7, { r: 255, g: 255, b: 0 });
                 target.active = false; // Mark target as inactive
                 knife.active = false; // Mark knife as inactive (stuck in target)
                 knife.vx = 0; knife.vy = 0; // Stop knife
                 updateUI();
                 // Check if all targets inactive
                 var allHit = targets.every(function(t) { return !t.active; });
                 if (allHit) { levelComplete(); }
            }

            function handleDestructibleHit(obstacle, knife) {
                 obstacle.health -= 1;
                 console.log("Destructible hit! Health:", obstacle.health);
                 createParticles(knife.x, knife.y, 3, { r: 139, g: 69, b: 19 });
                 knife.active = false; // Knife stops/sticks
                 knife.vx = 0; knife.vy = 0;

                 if (obstacle.health <= 0) {
                     console.log("Destructible destroyed!");
                     score += obstacle.points || 0;
                     createParticles(obstacle.x, obstacle.y, 10, { r: 139, g: 69, b: 19 });
                     obstacle.active = false; // Mark obstacle as inactive/destroyed
                     updateUI();
                 }
            }

            function handleKnifeStick(knife) {
                 if (knife.active) {
                     knife.active = false;
                     knife.vx = 0; knife.vy = 0;
                     console.log("Knife stuck");
                 }
            }

            function createParticles(x, y, count, color) { for (var i = 0; i < count; i++) { particles.push({ x: x, y: y, radius: Math.random() * 3 + 1, color: color, life: 20 + Math.random() * 15, alpha: 0.8 }); } } // Simpler particles
            function updateUI() { scoreElement.textContent = "Score: " + score; knivesLeftElement.textContent = "Knives: " + knivesRemaining; var allTargetsHit = targets.every(function(t) { return !t.active; }); if (knivesRemaining <= 0 && !allTargetsHit && !isAiming && !knivesInAir.some(function(k){return k.active;})) { setTimeout(function() { if (knivesRemaining <= 0 && targets.some(function(t){return t.active;})) { gameOver(); } }, 1000); } }

            // --- Game State Functions ---
            function levelComplete() { console.log("Level Complete!"); if (currentLevel < levels.length - 1) { showMessage("<h2>Level " + (currentLevel + 1) + " Complete!</h2><p>Score: " + score + "</p>"); } currentLevel++; setTimeout(function() { if (currentLevel >= levels.length) { handleGameWin(); } else { loadLevel(currentLevel); } }, 1500); }
            function gameOver() { console.log("Game Over!"); showMessage("<h2>Game Over!</h2><p>Try Again!</p>"); }
            function generatePrizeCode() { var timestamp = Date.now(); var randomLetters = ''; var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; for (var i = 0; i < 4; i++) { randomLetters += characters.charAt(Math.floor(Math.random() * characters.length)); } return "PRIZE-" + timestamp + "-" + randomLetters; }
            function handleGameWin() { console.log("Game Won!"); var prizeCode = generatePrizeCode(); var xComposeUrl = "https://x.com/compose/post"; var winMessageHTML = '<h2>ðŸŽ‰ Congratulations! You won! ðŸŽ‰</h2><p>Your code: <span class="prize-code">' + prizeCode + '</span></p><div class="instructions"><p><strong>Instructions:</strong></p><p>1. Create a post about $STAB on X and tag @croc_with_knife.</p><p>2. Then DM @croc_with_knife the code.</p></div><a href="' + xComposeUrl + '" target="_blank" rel="noopener noreferrer"><button>Create Post on X</button></a>'; showMessage(winMessageHTML); }
            function showMessage(htmlContent) { messageBox.innerHTML = htmlContent; messageBox.style.display = 'block'; }
            function hideMessage() { messageBox.style.display = 'none'; }

            // --- Start Loading Assets ---
            loadAssets(); // Start loading, init() will be called on completion

        } // End of setupGame function

        // Call the main setup function when DOM is ready
        if (document.readyState === 'loading') { // Handle cases where DOM might already be ready
            document.addEventListener('DOMContentLoaded', setupGame);
        } else {
            setupGame(); // DOM is already ready, call setup directly
        }

    </script>

</body>
</html>
